{
  "collaboration_principles": {
    "work_pace": "Slow and meticulous - quality over speed",
    "error_prevention": "Thoroughness prevents bugs - avoid rushing",
    "code_quality": "Simple, readable code over complex solutions",
    "decision_making": "Consult human for important/complex decisions"
  },

  "code_standards": {
    "naming_consistency": {
      "importance": "Critical - maintain consistent naming throughout",
      "examples": [
        "snake_case for variables and functions",
        "PascalCase for classes",
        "UPPER_CASE for constants",
        "Descriptive names over short abbreviations"
      ]
    },

    "type_safety": {
      "importance": "Mandatory - ensure strong typing",
      "requirements": [
        "Type hints for all function parameters and returns",
        "Pydantic models for data validation",
        "SQLAlchemy models with proper type annotations",
        "Use mypy-compatible type annotations"
      ]
    },

    "simplicity": {
      "motto": "Simple code over clever code",
      "guidelines": [
        "Prefer explicit over implicit",
        "Avoid overly complex abstractions",
        "Break down complex functions into smaller parts",
        "Clear variable names that explain intent"
      ]
    }
  },

  "workflow_process": {
    "checkpoint_system": {
      "principle": "Large tasks split into checkpoints",
      "process": [
        "1. Claude implements checkpoint",
        "2. Claude presents results to human",
        "3. Human validates implementation",
        "4. If approved: commit and push to GitHub",
        "5. Move to next checkpoint"
      ],
      "checkpoint_criteria": [
        "Logical completion point",
        "Testable functionality",
        "No breaking changes",
        "Clear progress demonstration"
      ]
    },

    "git_workflow": {
      "commit_frequency": "After each validated checkpoint",
      "commit_messages": "Clear, concise German messages",
      "branch_strategy": "Work on main branch for personal project",
      "push_timing": "Only after human validation and approval"
    }
  },

  "decision_making_framework": {
    "auto_decisions": [
      "Code formatting and style consistency",
      "Simple bug fixes with obvious solutions",
      "Adding type hints and documentation",
      "Refactoring for better readability"
    ],

    "consult_human_for": [
      "Architectural changes or new patterns",
      "Database schema modifications",
      "API endpoint changes or additions",
      "Third-party library selections",
      "Security-related implementations",
      "Performance optimization strategies",
      "AI integration design decisions",
      "Complex business logic implementations"
    ],

    "consultation_format": {
      "present_options": "Show multiple approaches with pros/cons",
      "explain_implications": "Describe impact of each choice",
      "recommend_preferred": "Suggest best option with reasoning",
      "await_approval": "Wait for explicit human decision"
    }
  },

  "communication_style": {
    "progress_reporting": {
      "frequency": "At each checkpoint completion",
      "content": [
        "What was implemented",
        "Any issues encountered and solutions",
        "Current status and next steps",
        "Any decisions that need human input"
      ]
    },

    "documentation": {
      "code_comments": "Explain complex logic and business rules",
      "docstrings": "All public functions and classes",
      "readme_updates": "Keep documentation current with changes",
      "changelog": "Document significant changes and decisions"
    }
  },

  "quality_assurance": {
    "before_checkpoint_presentation": [
      "Run linting (ruff check)",
      "Run formatting (ruff format)",
      "Run tests (pytest)",
      "Verify type safety",
      "Check for naming consistency",
      "Ensure code simplicity"
    ],

    "testing_approach": {
      "unit_tests": "For business logic and services",
      "integration_tests": "For database operations and API endpoints",
      "test_first": "Consider tests when implementing new features",
      "coverage": "Aim for meaningful coverage, not just numbers"
    }
  },

  "learning_and_adaptation": {
    "feedback_incorporation": "Adapt based on human feedback and preferences",
    "pattern_recognition": "Learn from previous decisions and apply consistently",
    "continuous_improvement": "Refine approach based on what works well",
    "documentation_updates": "Update this guide as we discover new patterns"
  },

  "collaboration_insights": {
    "sam_working_style": {
      "decision_making": "Values thorough analysis and quality-focused approach",
      "feedback_style": "Direct and constructive - appreciates honest technical assessment",
      "pace_preference": "Explicitly stated: 'langsam und gewissenhaft' - slow and careful over fast",
      "technical_depth": "Strong attention to detail - catches outdated syntax (Optional vs |), version inaccuracies",
      "communication": "German/English mix - comfortable with technical German terms",
      "validation_approach": "Prefers step-by-step validation with testing in venv before proceeding"
    },

    "effective_patterns": {
      "task_breakdown": "Large async migration broken into clear checkpoints works well",
      "progress_communication": "Regular todo list updates provide good visibility",
      "quality_checks": "Testing syntax in venv before proceeding prevents issues",
      "decision_points": "Sam appreciates being asked about architectural approaches rather than assumptions",
      "documentation": "Comprehensive roadmaps and progress tracking are valued"
    },

    "lessons_learned": {
      "version_research": "Always verify package versions with Sam - he has more current information",
      "technical_correctness": "Sam catches technical details (type syntax, async patterns) - appreciate this feedback",
      "scope_management": "Better to pause and ask when scope becomes very large (30+ changes)",
      "modern_practices": "Stay current with Python syntax and patterns - Sam values modern approaches"
    },

    "claude_observations": {
      "about_sam": [
        "Technically knowledgeable with strong attention to detail",
        "Values quality and thoroughness over speed - explicitly stated priority",
        "Provides excellent technical feedback and corrections",
        "Good at catching outdated patterns and suggesting modern alternatives",
        "Appreciates honest assessment even when critical",
        "Prefers collaborative decision-making for complex changes"
      ],
      "about_collaboration": [
        "Works well with structured approach and checkpoints",
        "Appreciates when Claude asks for validation before large changes",
        "Responds well to direct technical communication",
        "Values transparency about complexity and scope",
        "Good feedback loop for continuous improvement"
      ]
    }
  },

  "ai_integration_specific": {
    "langchain_decisions": [
      "Chain architecture choices",
      "Memory system design decisions",
      "Prompt engineering strategies",
      "Model selection and configuration"
    ],

    "performance_considerations": [
      "Streaming vs batch processing",
      "Caching strategy decisions",
      "Background task prioritization",
      "Memory management approaches"
    ]
  },

  "future_evolution": {
    "guide_updates": "This document will evolve as we work together",
    "pattern_library": "Build collection of proven approaches",
    "decision_log": "Track important architectural decisions made",
    "lessons_learned": "Document what works well and what doesn't"
  }
}